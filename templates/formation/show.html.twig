{% extends 'base.html.twig' %}
{% block title %}Formation â€” {{ subcategory.name }}{% endblock %}

{% set canEdit = canEdit|default(false) %}
{% set backUrl = path('formation_category', { code: subcategory.code }) %}

{% block stylesheets %}
  {{ parent() }}
  <style>
    .formation-scope{overflow-x: clip;}

    .formation-toolbar{
      position:sticky;top:0;z-index:10;background:#fff;border-bottom:1px solid #e5e7eb;
      padding:.5rem .75rem;display:flex;gap:.5rem;align-items:center;justify-content:space-between
    }
    .tool-buttons{display:flex;gap:.35rem;flex-wrap:wrap}
    .tool-buttons .btn{padding:.3rem .5rem;font-size:.9rem}

    .canvas{width:100%;max-width:none;margin:1rem 0;display:flex;flex-direction:column;gap:12px}

    /* Bloc = 1 colonne, gutter en absolute */
    .block{
      background:#fff;border:1px dashed transparent;border-radius:.4rem;padding:.4rem;
      display:grid;grid-template-columns:minmax(0,1fr);column-gap:8px;align-items:start;
      position:relative; /* nÃ©cessaire pour le badge en bas Ã  droite */
    }
    .block.editing{border-color:#d1d5db}
    .block .body{min-width:0;width:100%;}
    .block.selected{ outline:2px solid #22c55e; }

    /* Badge compteur de questions (Ã©dition uniquement) */
    .qcount{
      position:absolute; right:.45rem; bottom:.45rem;
      background:#000; color:#fff;
      font-size:.65rem; line-height:1;
      padding:.15rem .4rem; border-radius:999px;
      opacity:.85; pointer-events:none; z-index:3;
    }

    /* Indentation */
    .block.chapter    { margin-left: 1vw; }
    .block.subchapter { margin-left: 4vw; }
    .block.p-full     { margin-left: 7vw; }
    .block.img-full   { margin-left: 7vw; }
    .block.split      { margin-left: 7vw; }

    /* Gutter (poignÃ©e + corbeille) */
    .gutter{
      position:absolute;left:-28px;top:.2rem;
      width:24px;display:flex;flex-direction:column;gap:.25rem;align-items:center
    }
    @media (max-width: 768px){
      .gutter{ left:-24px; }
    }

    .handle{
      width:28px;height:28px;display:flex;align-items:center;justify-content:center;
      border:1px solid #e5e7eb;border-radius:.35rem;background:#f8fafc;cursor:grab;
      font-size:1rem;line-height:1;user-select:none
    }
    .handle:active{cursor:grabbing}
    .rm{
      width:28px;height:28px;display:flex;align-items:center;justify-content:center;
      border:1px solid #f1d5d8;border-radius:.35rem;background:#fff;color:#b4232a
    }
    .rm:hover{background:#fff0f1}

    .p-full .content{min-height:80px;padding:8px;background:#fafafa;border-radius:.35rem;border:1px solid #eee}
    .img-full img,.split-grid img{max-width:100%;height:auto;border-radius:.35rem;border:1px solid #eee;display:block}

    /* ====== Bloc SPLIT (2 colonnes + poignÃ©e centrale) ====== */
    .split-grid{
      --split-gap: 16px; /* largeur de la poignÃ©e centrale (zone cliquable) */
      display:grid;
      grid-template-columns:minmax(0,1fr) var(--split-gap) minmax(0,1fr);
      gap:12px;
      align-items:stretch;          /* <â€” la poignÃ©e occupe toute la hauteur */
    }
    .split-grid > *{min-width:0}

    .split-grid .text{
      min-height:80px;padding:8px;background:#fafafa;border-radius:.35rem;border:1px solid #eee
    }

    /* poignÃ©e de redimensionnement (colonne centrale) */
    .split-grid .resize-col{
      cursor: col-resize;
      user-select: none;
      touch-action: none;
      position: relative;
      width:100%;
      height:100%;
      z-index: 2;
      background: transparent;
    }
    .split-grid .resize-col::after{
      content:'';
      position:absolute; top:0; bottom:0; left:50%;
      transform:translateX(-50%);
      width:2px; background:#e5e7eb;
      border-radius:1px;
      pointer-events:none;
    }
    .split-grid .resize-col:hover::after{ background:#cbd5e1; }
    .split-grid.resizing .resize-col::after{ background:#9ca3af; }

    .chapter{font-weight:700;font-size:1.4rem;margin:.2rem 0}
    .subchapter{font-weight:600;font-size:1.15rem;margin:.15rem 0}

    .placeholder{
      display:flex;align-items:center;justify-content:center;min-height:140px;
      background:#f3f4f6;border:1px dashed #cbd5e1;border-radius:.35rem;color:#6b7280;cursor:pointer
    }

    /* Placeholder pour contenteditable */
    .content[contenteditable][data-ph]:empty::before,
    .split-grid .text[contenteditable][data-ph]:empty::before{
      content: attr(data-ph);
      color:#9ca3af; pointer-events:none;
    }

    /* ===== Menu contextuel (clic droit) ===== */
    .qmenu{
      position:fixed; z-index: 2000; min-width: 320px;
      background:#fff; border:1px solid #e5e7eb; border-radius:.5rem;
      box-shadow:0 10px 20px rgba(0,0,0,.12);
      overflow:hidden; display:none;
    }
    .qmenu .item{
      padding:.5rem .75rem; cursor:pointer; display:flex; align-items:center; gap:.5rem;
    }
    .qmenu .item:hover{ background:#f8fafc; }
    .qmenu .item.add{ background:#dcfce7; font-weight:600; }
    .qmenu .empty{ padding:.5rem .75rem; color:#6b7280; }
    .qmenu .sep{ height:1px; background:#e5e7eb; margin:.25rem 0; }
  </style>
{% endblock %}

{% block body %}
<div class="formation-scope">
  <div class="container-fluid">

    <div class="d-flex justify-content-between align-items-center mt-3 mb-2">
      <h1 class="h5 m-0">Formation â€” {{ subcategory.name }}</h1>
      <div class="d-flex gap-2">
        {% if not canEdit %}
          <form method="post" action="{{ path('formation_report', { id: subcategory.id }) }}" class="d-inline">
            <input type="hidden" name="_token" value="{{ csrf_token('formation_report_' ~ subcategory.id) }}">
            <button class="btn btn-outline-warning" type="submit">Signaler</button>
          </form>
        {% endif %}
        <a class="btn btn-outline-secondary" href="{{ backUrl }}">Quitter</a>
        {% if canEdit %}
          <button id="btn-save" class="btn btn-primary">Enregistrer</button>
        {% endif %}
        {% if not canEdit %}
          <a class="btn btn-outline-primary" href="{{ path('formation_pdf', { id: subcategory.id }) }}" target="_blank">TÃ©lÃ©charger PDF</a>
        {% endif %}
      </div>
    </div>

    {% if canEdit %}
      <div class="formation-toolbar">
        <div class="tool-buttons">
          <button class="btn btn-outline-secondary" data-insert="chapter">+ Chapitre</button>
          <button class="btn btn-outline-secondary" data-insert="subchapter">+ Sous-titre</button>
          <button class="btn btn-outline-secondary" data-insert="p-full">+ Paragraphe (100%)</button>
          <button class="btn btn-outline-secondary" data-insert="img-full">+ Image (100%)</button>
          <button class="btn btn-outline-secondary" data-insert="left-text-right-img">+ Texte gauche / Image droite</button>
          <button class="btn btn-outline-secondary" data-insert="left-img-right-text">+ Image gauche / Texte droite</button>
        </div>
        <small class="text-muted">Cliquez une image pour la remplacer â€¢ ðŸ—‘ pour supprimer â€¢ â‹®â‹® pour dÃ©placer â€¢ Clic gauche sur la barre centrale pour redimensionner</small>
      </div>
    {% endif %}

    <div id="canvas"
         class="canvas"
         data-edit="{{ canEdit ? '1' : '0' }}"
         {% if canEdit %}
           data-upload-url="{{ path('formation_upload', { id: subcategory.id }) }}"
           data-save-url="{{ path('formation_save',   { id: subcategory.id }) }}"
         {% endif %}
    >
      {# Rendu des blocs avec id ancrÃ© b-<index> pour retour #}
      {% for b in blocks %}
        {% set t = b.type %}
        {% if t in ['chapter','subchapter','p-full','img-full','left-text-right-img','left-img-right-text'] %}
          {% set isSplit = t in ['left-text-right-img','left-img-right-text'] %}
          <div id="b-{{ loop.index0 }}"
               class="block {{ t }}{% if isSplit %} split{% endif %}{% if canEdit %} editing{% endif %}"
               data-type="{{ t }}"
               data-idx="{{ loop.index0 }}">
            {% if canEdit %}
              <div class="gutter">
                <div class="handle" draggable="true" title="DÃ©placer">â‹®â‹®</div>
                <button type="button" class="rm" title="Supprimer">ðŸ—‘</button>
              </div>
            {% endif %}

            <div class="body">
              {% if t == 'chapter' %}
                <div class="chapter">
                  <span class="content" {{ canEdit ? 'contenteditable=true' : '' }}>{{ b.text|e }}</span>
                </div>
              {% elseif t == 'subchapter' %}
                <div class="subchapter">
                  <span class="content" {{ canEdit ? 'contenteditable=true' : '' }}>{{ b.text|e }}</span>
                </div>
              {% elseif t == 'p-full' %}
                <div class="p-full">
                  <div class="content" {{ canEdit ? 'contenteditable=true' : '' }}>{{ b.text|raw }}</div>
                </div>
              {% elseif t == 'img-full' %}
                <div class="img-full">
                  {% if b.path %}<img src="{{ asset(b.path) }}" alt="">{% else %}<div class="placeholder">Cliquez pour choisir une imageâ€¦</div>{% endif %}
                </div>
              {% elseif t == 'left-text-right-img' %}
                <div class="split-grid" style="grid-template-columns: {{ b.cols|default('minmax(0,1fr) var(--split-gap) minmax(0,1fr)') }};">
                  <div class="text" {{ canEdit ? 'contenteditable=true' : '' }}>{{ b.text|raw }}</div>
                  <div class="resize-col" aria-hidden="true"></div>
                  <div class="img">
                    {% if b.path %}<img src="{{ asset(b.path) }}" alt="">{% else %}<div class="placeholder">Cliquez pour choisir une imageâ€¦</div>{% endif %}
                  </div>
                </div>
              {% elseif t == 'left-img-right-text' %}
                <div class="split-grid" style="grid-template-columns: {{ b.cols|default('minmax(0,1fr) var(--split-gap) minmax(0,1fr)') }};">
                  <div class="img">
                    {% if b.path %}<img src="{{ asset(b.path) }}" alt="">{% else %}<div class="placeholder">Cliquez pour choisir une imageâ€¦</div>{% endif %}
                  </div>
                  <div class="resize-col" aria-hidden="true"></div>
                  <div class="text" {{ canEdit ? 'contenteditable=true' : '' }}>{{ b.text|raw }}</div>
                </div>
              {% endif %}
            </div>

            {# badge compteur (injectÃ©/maj en JS quand canEdit) #}
            {% if canEdit %}
              <div class="qcount" aria-hidden="true">â€¦</div>
            {% endif %}
          </div>
        {% endif %}
      {% endfor %}
    </div>

    {# ===== Menu contextuel (invisible par dÃ©faut) ===== #}
    <div id="qmenu" class="qmenu" role="menu" aria-hidden="true"></div>

  </div>
</div>
{% endblock %}

{% block javascripts %}
{{ parent() }}
<script>
(() => {
  document.addEventListener('DOMContentLoaded', () => {
    const canvas = document.getElementById('canvas');
    if (!canvas) return;

    const IS_EDIT = canvas.dataset.edit === '1';
    const SUB_ID = {{ subcategory.id }};

    const uploadUrl = canvas.dataset.uploadUrl;
    const saveUrl   = canvas.dataset.saveUrl;

    // ===== Helpers placeholders =====
    function normalizeEmpty(el){
      const txt = (el.innerText || '').replace(/\u200B/g,'').trim();
      if (txt === '') el.innerHTML = '';
    }
    function ensureEditors(scope = canvas){
      scope.querySelectorAll('.block.chapter .content, .block.subchapter .content')
        .forEach(el => {
          el.setAttribute('contenteditable','true');
          if (!el.hasAttribute('data-ph')) {
            const isChap = el.closest('.block').classList.contains('chapter');
            el.setAttribute('data-ph', isChap ? 'Nouveau chapitre' : 'Sous-titre');
          }
          normalizeEmpty(el);
        });
      scope.querySelectorAll('.block.p-full .content')
        .forEach(el => { el.setAttribute('contenteditable','true'); if (!el.hasAttribute('data-ph')) el.setAttribute('data-ph','Paragrapheâ€¦'); normalizeEmpty(el); });
      scope.querySelectorAll('.block.split .text')
        .forEach(el => { el.classList.add('content'); el.setAttribute('contenteditable','true'); if (!el.hasAttribute('data-ph')) el.setAttribute('data-ph','Texteâ€¦'); normalizeEmpty(el); });
    }
    canvas.addEventListener('input', (e)=>{ const el = e.target.closest('[contenteditable][data-ph]'); if (el) normalizeEmpty(el); });

    // ===== CrÃ©ateurs =====
    const mk = {
      chapter: () => tpl('chapter', `<span class="content" contenteditable="true" data-ph="Nouveau chapitre"></span>`),
      subchapter: () => tpl('subchapter', `<span class="content" contenteditable="true" data-ph="Sous-titre"></span>`),
      'p-full': () => tpl('p-full', `<div class="content" contenteditable="true" data-ph="Paragrapheâ€¦"></div>`),
      'img-full': () => tpl('img-full', `<div class="placeholder">Cliquez pour choisir une imageâ€¦</div>`),
      'left-text-right-img': () => tpl('left-text-right-img',
        `<div class="split-grid" style="grid-template-columns:minmax(0,1fr) var(--split-gap) minmax(0,1fr);">
           <div class="text content" contenteditable="true" data-ph="Texteâ€¦"></div>
           <div class="resize-col" aria-hidden="true"></div>
           <div class="img"><div class="placeholder">Cliquez pour choisir une imageâ€¦</div></div>
         </div>`),
      'left-img-right-text': () => tpl('left-img-right-text',
        `<div class="split-grid" style="grid-template-columns:minmax(0,1fr) var(--split-gap) minmax(0,1fr);">
           <div class="img"><div class="placeholder">Cliquez pour choisir une imageâ€¦</div></div>
           <div class="resize-col" aria-hidden="true"></div>
           <div class="text content" contenteditable="true" data-ph="Texteâ€¦"></div>
         </div>`),
    };
    function tpl(type, inner){
      const d = document.createElement('div');
      const isSplit = (type === 'left-text-right-img' || type === 'left-img-right-text');
      d.className = `block ${type} ${isSplit ? 'split ' : ''}editing`;
      d.dataset.type = type;
      d.innerHTML =
        `<div class="gutter">
           <div class="handle" draggable="true" title="DÃ©placer">â‹®â‹®</div>
           <button type="button" class="rm" title="Supprimer">ðŸ—‘</button>
         </div>
         <div class="body">${inner}</div>` + (IS_EDIT ? `<div class="qcount" aria-hidden="true">â€¦</div>` : ``);
      bindOne(d);
      ensureEditors(d);
      if (IS_EDIT) { initBlockCount(d); }
      return d;
    }
    document.querySelectorAll('[data-insert]').forEach(btn=>{
      btn.addEventListener('click', ()=> {
        const t = btn.dataset.insert;
        const node = mk[t]?.();
        if (node) canvas.appendChild(node);
      });
    });

    // ===== Suppression =====
    function bindDelete(scope){
      scope.querySelectorAll('.rm').forEach(btn=>{
        btn.addEventListener('click', (e)=> { e.stopPropagation(); btn.closest('.block')?.remove(); if (IS_EDIT) refreshAllCounts(); });
      });
    }

    // ===== DnD =====
    let dragging = null, dndInit = false;
    function attachCanvasDndOnce(){
      if (dndInit) return; dndInit = true;
      canvas.addEventListener('dragover', (e)=> {
        e.preventDefault();
        const after = getAfter(e.clientY);
        if (!dragging) return;
        if (after == null) canvas.appendChild(dragging);
        else canvas.insertBefore(dragging, after);
      });
      canvas.addEventListener('drop', ()=> {
        if (dragging) dragging.classList.remove('dragging');
        dragging = null;
        if (IS_EDIT) refreshAllCounts();
      });
      canvas.addEventListener('dragend', ()=> {
        if (dragging) dragging.classList.remove('dragging');
        dragging = null;
        if (IS_EDIT) refreshAllCounts();
      });
    }
    function bindDnd(scope){
      scope.querySelectorAll('.handle').forEach(h=>{
        h.addEventListener('dragstart', (e)=> { dragging = h.closest('.block'); dragging.classList.add('dragging'); e.dataTransfer.effectAllowed = 'move'; }, { passive: true });
      });
      attachCanvasDndOnce();
    }
    function getAfter(y){
      const els = [...canvas.querySelectorAll('.block:not(.dragging)')];
      let closest = null, offsetH = Number.NEGATIVE_INFINITY;
      els.forEach(el=>{ const r = el.getBoundingClientRect(); const off = y - r.top - r.height/2; if (off < 0 && off > offsetH) { offsetH = off; closest = el; } });
      return closest;
    }

    // ===== Upload image (UN SEUL handler global + garde anti-doublon) =====
    let imagePickerBound = false;
    let isPickingFile = false;

    function bindImagePickersOnce(){
      if (imagePickerBound) return;
      imagePickerBound = true;
      canvas.addEventListener('click', (e)=>{
        const ph  = e.target.closest('.placeholder');
        const img = (e.target.tagName === 'IMG') ? e.target : null;
        if (!ph && !img) return;
        if (isPickingFile) return; // anti double prompt
        isPickingFile = true;
        pickAndUpload((publicPath, url)=>{
          if (ph){
            const parent = ph.parentElement;
            const image = document.createElement('img');
            image.src = url;
            parent.innerHTML = '';
            parent.appendChild(image);
          } else if (img){
            img.src = url;
          }
          setTimeout(()=>{ isPickingFile = false; }, 50);
        }, () => { isPickingFile = false; });
      });
    }

    function pickAndUpload(cb, onFinally){
      const input = document.createElement('input'); input.type='file'; input.accept='image/*';
      input.onchange = async () => {
        try{
          if (!input.files || !input.files[0]) return;
          const fd = new FormData(); fd.append('file', input.files[0]);
          const res = await fetch(uploadUrl, { method:'POST', body: fd });
          const data = await res.json();
          if (data.ok && data.path){ cb(data.path, data.url || ('/'+data.path)); } else { alert('Upload Ã©chouÃ©'); }
        }catch{ alert('Erreur upload'); }
        finally{ if (onFinally) onFinally(); }
      };
      input.click();
    }

    // ===== Redimensionnement des blocs SPLIT =====
    function bindSplitResizers(scope){
      scope.querySelectorAll('.block.split .split-grid .resize-col').forEach(handle=>{
        const split = handle.closest('.split-grid');
        if (!split) return;

        const start = (pointer) => {
          pointer.preventDefault();
          startResize(pointer, split);
        };

        handle.addEventListener('mousedown', start);
        handle.addEventListener('touchstart', (e)=> start(e.touches[0]), { passive:false });
      });
    }

    function startResize(pointerEvent, split){
      const children = [...split.children];
      const leftEl  = children[0];
      const rightEl = children[2];

      const leftRect  = leftEl.getBoundingClientRect();
      const rightRect = rightEl.getBoundingClientRect();

      const total = (leftRect.width + rightRect.width);
      const startX = pointerEvent.clientX ?? pointerEvent.pageX;

      split.classList.add('resizing');

      function onMove(ev){
        const clientX = ev.clientX ?? (ev.touches && ev.touches[0]?.clientX) ?? startX;
        let newLeft = leftRect.width + (clientX - startX);
        const min = 120; // largeur mini des colonnes
        newLeft = Math.max(min, Math.min(total - min, newLeft));
        const newRight = total - newLeft;
        split.style.gridTemplateColumns = `${Math.round(newLeft)}px var(--split-gap) ${Math.round(newRight)}px`;
      }

      function onUp(){
        split.classList.remove('resizing');
        window.removeEventListener('mousemove', onMove);
        window.removeEventListener('mouseup', onUp);
        window.removeEventListener('touchmove', onMove);
        window.removeEventListener('touchend', onUp);
      }

      window.addEventListener('mousemove', onMove);
      window.addEventListener('mouseup', onUp);
      window.addEventListener('touchmove', onMove, { passive:false });
      window.addEventListener('touchend', onUp);
    }

    // ====== Compteur de questions (Ã©dition) ======
    function blockIndex(el){
      const d = el.getAttribute('data-idx');
      if (d !== null) return parseInt(d, 10);
      const list = Array.from(canvas.querySelectorAll('.block'));
      return Math.max(0, list.indexOf(el));
    }

    async function fetchQuestionsCount(idx){
      try{
        const resp = await fetch(`{{ path('castellum_api_questions') }}?subId=${SUB_ID}&chapter=${idx}`);
        if (!resp.ok) return 0;
        const data = await resp.json();
        if (!data.ok) return 0;
        return Array.isArray(data.items) ? data.items.length : 0;
      }catch{ return 0; }
    }

    function setBadge(block, value){
      let b = block.querySelector('.qcount');
      if (!b){
        b = document.createElement('div');
        b.className = 'qcount';
        block.appendChild(b);
      }
      b.textContent = String(value);
    }

    async function initBlockCount(block){
      setBadge(block, 'â€¦');
      const idx = blockIndex(block);
      const n = await fetchQuestionsCount(idx);
      setBadge(block, n);
    }

    function refreshAllCounts(){
      const blocks = canvas.querySelectorAll('.block');
      blocks.forEach(b => initBlockCount(b));
    }

    // ===== Sauvegarde =====
    function collect(){
      const out = [];
      canvas.querySelectorAll('.block').forEach(b=>{
        const type = b.dataset.type; if (!type) return;

        if (type === 'chapter' || type === 'subchapter'){
          const text = (b.querySelector('.content')?.innerText ?? '').trim();
          out.push({ type, text });
          return;
        }

        if (type === 'p-full'){
          const html = (b.querySelector('.content')?.innerHTML ?? '').trim();
          out.push({ type, text: html });
          return;
        }

        if (type === 'img-full'){
          const p = b.querySelector('img')?.getAttribute('src') || '';
          out.push({ type, path: p.replace(/^\/+/,'') });
          return;
        }

        if (type === 'left-text-right-img' || type === 'left-img-right-text'){
          const split = b.querySelector('.split-grid');
          const html  = (b.querySelector('.text')?.innerHTML ?? '').trim();
          const p     = b.querySelector('.img img')?.getAttribute('src') || '';
          let cols = '';
          if (split){
            cols = split.style.gridTemplateColumns?.trim() || '';
            if (!cols){
              const children = [...split.children];
              const leftW  = children[0].getBoundingClientRect().width;
              const rightW = children[2].getBoundingClientRect().width;
              cols = `${Math.round(leftW)}px var(--split-gap) ${Math.round(rightW)}px`;
            }
          }
          out.push({ type, text: html, path: p.replace(/^\/+/,'') , cols });
          return;
        }
      });
      return out;
    }

    document.getElementById('btn-save')?.addEventListener('click', async ()=>{
      const blocks = collect();
      try{
        const res = await fetch(saveUrl, { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ blocks }) });
        const data = await res.json();
        if (data.ok) alert('Contenu enregistrÃ©.'); else alert('Erreur sauvegarde');
      }catch{ alert('Erreur rÃ©seau'); }
    });

    function bindOne(scope){
      bindDelete(scope);
      bindDnd(scope);
      bindSplitResizers(scope);
      // picker dâ€™image attachÃ© une seule fois (voir plus bas)
    }

    // Bind initial + placeholders
    bindOne(canvas);
    ensureEditors(canvas);
    bindImagePickersOnce();

    // Compteurs au chargement + aprÃ¨s actions qui changent lâ€™index
    if (IS_EDIT) refreshAllCounts();

    // ======== Menu contextuel Questions (clic droit) ========
    const qmenu = document.getElementById('qmenu');

    function closeMenu(){ qmenu.style.display='none'; qmenu.innerHTML=''; document.querySelectorAll('.block.selected').forEach(b=>b.classList.remove('selected')); }
    document.addEventListener('click', (e)=> { if (!qmenu.contains(e.target)) closeMenu(); });
    window.addEventListener('blur', closeMenu);
    window.addEventListener('resize', closeMenu);
    document.addEventListener('scroll', closeMenu, true);

    async function openQuestionsMenu(block, x, y){
      const idx = blockIndex(block);
      document.querySelectorAll('.block.selected').forEach(b=>b.classList.remove('selected'));
      block.classList.add('selected');

      let items = [];
      try{
        const resp = await fetch(`{{ path('castellum_api_questions') }}?subId=${SUB_ID}&chapter=${idx}`);
        if (resp.ok){
          const data = await resp.json();
          if (data.ok) items = data.items || [];
        }
      }catch(e){ console.error(e); }

      const returnUrl = encodeURIComponent(`${location.origin}${location.pathname}?edit={{ canEdit ? '1':'0' }}#b-${idx}`);
      const addUrl = `{{ path('castellum_question_new', { id: subcategory.id }) }}?chapter=${idx}&return=${returnUrl}`;

      qmenu.innerHTML = '';
      const add = document.createElement('div');
      add.className = 'item add';
      add.textContent = 'âž•  Ajouter question';
      add.addEventListener('click', ()=> { closeMenu(); location.href = addUrl; });
      qmenu.appendChild(add);

      if (items.length){
        qmenu.appendChild(Object.assign(document.createElement('div'),{className:'sep'}));
        items.forEach(it=>{
          const row = document.createElement('div');
          row.className = 'item';
          row.textContent = it.label || ('Question #'+it.id);
          row.addEventListener('click', ()=>{
            closeMenu();
            const editUrl = `{{ path('castellum_question_edit', { id: 0 }) }}`.replace('/0/','/'+it.id+'/') + `?return=${returnUrl}`;
            location.href = editUrl;
          });
          qmenu.appendChild(row);
        });
      } else {
        const empty = document.createElement('div');
        empty.className = 'empty';
        empty.textContent = 'Aucune question liÃ©e Ã  ce bloc.';
        qmenu.appendChild(empty);
      }

      qmenu.style.display = 'block';
      const r = qmenu.getBoundingClientRect();
      const vw = window.innerWidth, vh = window.innerHeight;
      const left = Math.min(x, vw - r.width - 8);
      const top  = Math.min(y, vh - r.height - 8);
      qmenu.style.left = left + 'px';
      qmenu.style.top  = top + 'px';
    }

    canvas.addEventListener('click', (e)=>{
      const b = e.target.closest('.block'); if (!b) return;
      document.querySelectorAll('.block.selected').forEach(x=>x.classList.remove('selected'));
      b.classList.add('selected');
    });

    canvas.addEventListener('contextmenu', (e)=>{
      const b = e.target.closest('.block'); if (!b) return;
      e.preventDefault();
      openQuestionsMenu(b, e.clientX, e.clientY);
    });

    if (location.hash && /^#b-\d+$/.test(location.hash)){
      const el = document.querySelector(location.hash);
      if (el){ el.classList.add('selected'); el.scrollIntoView({behavior:'smooth', block:'center'}); }
    }
  });
})();
</script>
{% endblock %}
